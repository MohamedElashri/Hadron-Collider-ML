////////////////////////////////////////////////////////////////////////
// Class:       Mono
// Module Type: analyzer
// File:        Mono_module.cc
//
// Generated at Thu Mar 14 13:30:55 2019 by Mohamed Elashri using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

// Framework includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// NOvASoft includes
#include "RawData/RawDigit.h"
#include "RawData/FlatDAQData.h"
#include "RawData/RawTrigger.h"

// ROOT includes
#include <TTree.h>

// DDT includes
#include "DAQDataFormats/TriggerDefines.h"
#include "DAQDataFormats/RawEvent.h"
#include "DAQDataFormats/RawTrigger.h"
#include "DAQDataFormats/RawTriggerMask.h"
#include "DAQDataFormats/RawDataBlock.h"
#include "OnlineMonitoring/producer/RawEventUnpacker.cxx"
 #include "DAQ2RawDigit/OnlineUnpack.h"

// Standard C++ libraries
#include "iostream"






namespace Mono {
  class Mono;
}

class Mono::Mono : public art::EDAnalyzer {
public:
  explicit Mono(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  Mono(Mono const &) = delete;
  Mono(Mono &&) = delete;
  Mono & operator = (Mono const &) = delete;
  Mono & operator = (Mono &&) = delete;

  // Required functions.
  //void Trigger(daqdataformats::RawEvent& rawevt);
  //void Trigger1(daq2raw::OnlineUnpack& ee);
  void analyze(art::Event const & e) override;
  void endSubRun(art::SubRun const & s) override;
  void beginJob() override;
  void endJob() override;
  //bool UnpackRawDaqData(art::Event const& evt, daqdataformats::RawEvent& rawevt);

private:
  unsigned int fRun;         ///< Run number
  unsigned int fSubRun;      ///< Subrun number
  unsigned int fEvent;       ///< Event number
  unsigned int fTrigger;         ///< Trigger type
  // uint32_t     fprescale;    ///< prescale number
  unsigned int n_events;         /// sum of prescale
  uint32_t     fprescale;    ///< prescale number
  unsigned int prescale_sum;
  std::string  fRawDataLabel; ///< ART module label for Raw Data

  // Declare member data here.
  // This ART Service allows us to interact with TFiles on disk.
  art::ServiceHandle<art::TFileService> tfs;
  TTree* Job;

};


Mono::Mono::Mono(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),  // ,
  fRun(0),
  fSubRun(0),
  fEvent(0),
  fTrigger(0),
  fprescale(0),
  fRawDataLabel(p.get<std::string>("RawDataLabel"))
{}


void Mono::Mono::analyze(art::Event const & e)
{

  fRun    = e.run();
  fSubRun = e.subRun();
  fEvent  = e.event();

  art::Handle< std::vector<rawdata::RawTrigger> > trigv;
  e.getByLabel(fRawDataLabel, trigv);
  const rawdata::RawTrigger& trig = (*trigv)[0];
  fTrigger = trig.fTriggerMask_TriggerType;


  art::Handle< std::vector<rawdata::RawTrigger> > rawtrigger;
  e.getByLabel(fRawDataLabel, rawtrigger);
  const rawdata::RawTrigger& pre = (*rawtrigger)[0];
  fprescale = pre.fTriggerMask_Prescale;

prescale_sum= 0;
prescale_sum += fprescale;
n_events += fEvent;



  // Now to print our values
std::cout << "run = " << fRun << std::endl;
std::cout << "SubRun = " << fSubRun << std::endl;
std::cout << "Event = " << fEvent << std::endl;
std::cout << "TriggerID = " << fTrigger << std::endl;
std::cout << "Prescale = " << fprescale << std::endl;

std::cout << "prescale total = " << prescale_sum << std::endl;

}


void Mono::Mono::endSubRun(art::SubRun const & s)

{
  std::cout << "n_events = " << n_events << std::endl;



  /*
  prescale_sum = 0;
  prescale_sum += fprescale;
  std::cout << "prescale total = " << prescale_sum << std::endl;
*/

/*
n_events = 0;
for (unsigned int i= 0; i <= fEvent; ++i)
{
  n_events += i;
}
std::cout << "number of events = " << n_events << std::endl;
*/




}
 void Mono::Mono::beginJob()
{

  Job = tfs->make<TTree>("Trigger", "Trigger");


  Job->Branch("Run",    &fRun);
  Job->Branch("SubRun", &fSubRun);
  Job->Branch("Event",  &fEvent);
  Job->Branch("TriggerID",    &fTrigger);
  Job->Branch("Prescale",    &fprescale);
  Job->Branch("number of events",    &n_events);







}

void Mono::Mono::endJob()
 {
  // Implementation of optional member function here.
}


DEFINE_ART_MODULE(Mono::Mono)
